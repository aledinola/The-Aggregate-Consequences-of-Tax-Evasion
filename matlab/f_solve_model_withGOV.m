function [obj_smm1,model_targets1,policy,r0,ED,ModelResults,agg,DataTargets] = f_solve_model_withGOV(guess,Parameters,bounds,flags,pnames)

%{
 This function solves the model (in general or partial equilibrium)

INPUTS:
- guess:      vector with parameters to be calibrated
- Parameters: structure with parameters
- bounds:     structure with bounds for calibration parameters. Each field
              is 1*2 vector
- flags:      structure with some flags
- pnames:     cell array of strings with names of parameters to be
              calibrated/estimated

OUTPUTS:
- obj_smm1:       distance between model targets and data targets
- model_targets1: vector with model targets
- policy:         matlab structure with policy functions
- r,ED:           interest rate and excess demand (these are scalars)
- ModelResults:   structure with several model results generated in "targets_compute_clean"
- agg:            structure with some aggregate outcomes

 AUXILIARY FILES:
 This file calls the following other functions or script:
 + "fun_parameters.m" script that computes grids
 + "PE_interpolation1.m" function that calls Fortran and solves the model
 + "targets_compute_clean.m" function that computes model targets, given policy
    functions and distribution generated by PE_interpolation1.
 + "fun_estimation.m" function that computes the distance b/w data targets and
    model targets.

 NOTES:
 Updated by Alesandro Di Nola on September 17, 2020. Folder RED.
%}

Parameters.beta           = guess(1);  % discount factor
Parameters.psi            = guess(2);  % utility weight labor
Parameters.delta          = guess(3);  % depreciation
Parameters.vi             = guess(4);  % span of control (production function)
Parameters.gamma          = guess(5);  % share of capital - self employed
Parameters.rho_theta      = guess(6);  % persistence of ability shock
Parameters.sigmaeps_theta = guess(7);  % stdev of ability shock
Parameters.uncmean_theta  = guess(8);  % unconditional mean of ability shock
Parameters.pn_1           = guess(9);  % parameter prob detection: intercept
Parameters.pn_2           = guess(10); % parameter prob detection: slope
Parameters.cc0            = guess(11); % fixed cost of evasion
Parameters.ksi_tax        = guess(12); % scale param for GS tax function
Parameters.lambda         = guess(13); % collateral constraint

%Convert bounds from struct to vector
bounds_vec = bounds2vec(bounds,pnames);

lbounds_vec = bounds_vec(:,1); %LOWER bounds
ubounds_vec = bounds_vec(:,2); %UPPER bounds

%check if parameters are within lower bounds
if any(guess<lbounds_vec)
    warning('Lower bounds on parameters violated!')
    obj_smm1 = realmax;
    model_targets1=[];policy=[];r0=[];ED=[];ModelResults=[];agg=[];
    DataTargets=[];
    return
end
%check if parameters are within upper bounds
if any(guess>ubounds_vec)
    warning('Upper bounds on parameters violated!')
    obj_smm1 = realmax;
    model_targets1=[];policy=[];r0=[];ED=[];ModelResults=[];agg=[];
    DataTargets=[];
    return
end


% Unpack some flags
do_GE          = flags.do_GE;
do_gov_loop    = flags.do_gov_loop;

%% Set other parameters and compute grids
[Parameters,Grids] = fun_parameters(Parameters,flags);

%---------- Interest rate loop: setup ------------------------------------%
% Compute the model solving for the general equilibrium
% Initial interval for interest rate> Suggested values:
% no tax evasion, no redistrib ==> [0.04,0.045]
% no tax evasion, lump-sum redistrib ==> [0.04,0.045]
LB_r        = 0.04; %initial lower bound
UB_r        = 0.045; %initial upper bound
r_pe        = 0.04;  %target
%r: Taxev GE:            0.04 (target)
%r: Notaxev GE:          0.0430711786779782;
%r: Notaxev GE lump-sum: 0.0431226122102071
%r: Notaxev GE tax cut:  0.042374447851706
tol_X       = 1e-5; %tolerance level for the changes in r/beta

%-------------- Government loop: setup -----------------------------------%
% tau_s is a parameter in tax function used to clear gov budget
% no tax evasion, lump-sum redistrib => tau_s interval = [-0.04,0].
% scale_a2 and scale_a2 are always equal to one.
tau_s_min = -0.04; tau_s_max = 0;
scale_min = 0.5; scale_max = 1.0;
scale_se_min = 0.05; scale_se_max = 0.2;
balance = 'lump_sum'; %OPTIONS are 'lump_sum','tax_cut','tax_cut_se'
G_fix       = 0.284359315236132; %fixed value for tax revenues (benchmark economy)
tol_g       = 0.0001;

if (do_gov_loop ==0)
    maxiter_g = 1; %Note: to skip gov loop, set maxiter_g=1 
    tau_s     = 0;
    %notaxev pe: -0.028125;
    %notaxev ge: -0.03203125;
    scale     = 1;
    scale_se  = 1;
elseif (do_gov_loop ==1)
    disp('Clear Government budget constraint')
    maxiter_g = 10;
    switch balance %We have different ways to balance the government budget constraint
        case 'lump_sum'
            scale = 1;
            scale_se = 1;
            tau_s = 0.5*(tau_s_min+tau_s_max);
        case 'tax_cut'
            scale = 0.5*(scale_min+scale_max);
            tau_s = 0;
            scale_se = 1;
        case 'tax_cut_se'
            scale_se = 0.5*(scale_se_min+scale_se_max);
            tau_s = 0;
            scale = 1;
        otherwise
            error('Option for "balance" does not exist!')
    end
else
    error('The flag "do_gov_loop" must be either 0 or 1!')
end

%-------------- Government loop setup - END -------------------------------%

tic

disp('------------------------------------------------')
if flags.loadV==0
    value.V1 = [];
elseif flags.loadV==1
    temp = load('Vguess.mat','Vguess');
    value.V1 = temp.Vguess;
end

iter_g = 0;
while iter_g < maxiter_g
    
    iter_g = iter_g+1;
    if maxiter_g>1
        disp('***********************************************************')
        disp('LOOP OVER GOVERNMENT BUDGET');
        fprintf('iter_g = %d \n',iter_g);
    end
    fprintf('tau_s (lump-sum government loop) is:          %f\n', tau_s);
    fprintf('scale_a2 (tax cut, government loop) is:       %f\n', scale);
    fprintf('scale_a2_entre (tax cut, government loop) is: %f\n', scale_se);
    
    % Update tax parameters (only for Gouveia-Strauss tax func.)
    % scale=1 in the benchmark economy
    if do_gov_loop==1
        if strcmp(balance,'tax_cut')
            Parameters.s_work  = (scale^Parameters.p_work)*(Parameters.ksi_tax^Parameters.p_work)*0.22;
            Parameters.s_entre = (scale^Parameters.p_entre)*(Parameters.ksi_tax^Parameters.p_entre)*0.44;
        elseif strcmp(balance,'tax_cut_se')
            Parameters.s_entre = (scale_se^Parameters.p_entre)*(Parameters.ksi_tax^Parameters.p_entre)*0.44;
        end
    end
    
    disp('---------------------------------------------------------------')
    if do_GE == 0 % run the model in partial equilibrium
        r0 = r_pe;
        % Here we don't need bisection to clear excess demand
        disp('Partial equilibrium: Solve the model with fixed interest rate')
        fprintf('r = %5.7f \n',r0)
        disp('---------------------------------------------------------------')
    elseif do_GE == 1 % run the model in general equilibrium
        disp('START GENERAL EQUILIBRIUM on interest rate')
        disp('Initial bracket for r:')
        disp([LB_r, UB_r])
        %Function to pass to rootfinding algo:
        myfun = @(r_m) PE_interpolation1(r_m,tau_s,Parameters,Grids,flags,value.V1);
        % we use matlab fzero, options 
        options = optimset('TolX',tol_X,'Display','iter');
        %------------------------------------%
        [r0, ED, flag_fzero] = fzero(myfun,[LB_r, UB_r],options);
        fprintf('Excess demand is: %f \n',ED);
        if flag_fzero <= 0
            warning('Be careful: Bisection did not converge!')
            obj_smm1 = realmax;DataTargets=[];
            model_targets1=[];policy=[];r0=[];ED=[];ModelResults=[];agg=[];
            return
        end
        disp('END GENERAL EQUILIBRIUM')
    end % end do_GE interest rate loop
    
    %Compute the model at the cleared excess demand (r0 in the code) or at a
    %given interest rate and compute objects of interest
    if isempty(value.V1)
        [ED,w0,agg,distrib,policy,value,exitflag_vfi,exitflag_mu] = PE_interpolation1(r0,tau_s,Parameters,Grids,flags,[]);
    else
        [ED,w0,agg,distrib,policy,value,exitflag_vfi,exitflag_mu] = PE_interpolation1(r0,tau_s,Parameters,Grids,flags,value.V1);
    end
    
    if (exitflag_vfi>0)
        warning('VFI did not converge successfully!')
        warning('Program will terminate')
        obj_smm1 = realmax;DataTargets=[];
        model_targets1=[];policy=[];r0=[];ED=[];ModelResults=[];agg=[];
        return
    elseif (exitflag_mu>0)
        warning('MU did not converge successfully!')
        warning('Program will terminate')
        obj_smm1 = realmax;DataTargets=[];
        model_targets1=[];policy=[];r0=[];ED=[];ModelResults=[];agg=[];
        return
    end
    
    %----- Do this part only if government loop is active ------%
    if (do_gov_loop ==1)
        fprintf('tau_s (lump-sum government) is:   %f\n', tau_s);
        fprintf('scale (tax_cut government) is:    %f\n', scale);
        fprintf('scale_se (tax_cut government) is: %f\n', scale_se);
        fprintf('Aggregate tax revenues: %f \n',agg.taxes_total);
        fprintf('Target: %f \n',G_fix);
        
        %How far are we from clearing the gov budget?
        dist_g = agg.taxes_total - G_fix;
        fprintf('Current aggregate taxes minus target: %f \n',dist_g);
        
        switch balance
            
            case 'lump_sum'
                if dist_g > tol_g %too much tax revenues, reduce tau_s
                    tau_s_max = tau_s;
                    tau_s = 0.5*(tau_s_min+tau_s_max);
                elseif dist_g < -tol_g %too few tax revenues, increase tau_s
                    tau_s_min = tau_s;
                    tau_s = 0.5*(tau_s_min+tau_s_max);
                else
                    break %exit gov loop
                end
                
            case 'tax_cut'
                if dist_g > tol_g %too much tax revenues, reduce scale
                    scale_max = scale;
                    scale = 0.5*(scale_min+scale_max);
                elseif dist_g < -tol_g %too few tax revenues, increase scale
                    scale_min = scale;
                    scale = 0.5*(scale_min+scale_max);
                else
                    break %exit gov loop
                end
                
            case 'tax_cut_se'
                if dist_g > tol_g %too much tax revenues, reduce scale_se
                    scale_se_max = scale_se;
                    scale_se = 0.5*(scale_se_min+scale_se_max);
                elseif dist_g < -tol_g %too few tax revenues, increase scale_se
                    scale_se_min = scale_se;
                    scale_se = 0.5*(scale_se_min+scale_se_max);
                else
                    break %exit gov loop
                end
                
                
            otherwise
                error('Option for "balance" is invalid')
                
                
        end %END switch balance
        
        
        
        
    end %END IF government loop
    %-----------------------------------------------------------%
    
    
end %end GOV loop

time_model_once = toc;
disp('Time to solve the model for given parameters:')
fprintf('%f seconds, or %f minutes  \n',time_model_once,time_model_once/60);

disp('Check excess demand')
disp('Excess demand is:')
disp(ED)
disp('Aggregate tax revenues are:')
disp(agg.taxes_total)

if Parameters.no_evasion==0
    % Tax evasion economy
    save last_run_taxevasion
elseif Parameters.no_evasion==1
    % NO tax evasion economy
    save last_run_notaxevasion
end

%Save final value function for later use
if flags.saveV==1 && flags.do_parallel==0 && exitflag_vfi==0 && exitflag_mu==0
    Vguess = value.V1;
    save('Vguess.mat','Vguess')
end

%% Compute model targets
% clear,clc
% load last_run_taxevasion

if (flags.display_iter==2);disp('Computing model targets. Please wait...');end

% computes model_targets
tic
[ModelResults,modelTargetsS] = targets_compute_clean(r0,w0,tau_s,scale,Parameters,Grids,value,distrib,policy,agg,flags,ED);
disp('Time (secs) to compute model targets (after model is solved):')
toc

%Set up model targets, data targets, etc.
[obj_smm1,model_targets1,DataTargets] = fun_estimation(pnames,guess,r0,Parameters,flags,modelTargetsS);

%Save results in .mat file.
% 2*2*2 options: taxev vs notaxev, PE vs GE, balance budget with lump-sum vs
% balance budget with tax cut
if flags.doSave==1
    if Parameters.no_evasion==0
        %% Tax evasion economy
        if do_GE==0
            %Partial equilibrium
            save([flags.results_folder,'\taxevasion_pe.mat'])
        elseif do_GE==1
            %General equilibrium
            save([flags.results_folder,'\taxevasion_ge.mat'])
        end
    elseif Parameters.no_evasion==1
        %% Counterfactual economy
        if do_GE==0
            if maxiter_g==1
                % NO tax evasion economy, partial equilibrium
                save([flags.results_folder,'\notaxevasion_pe.mat'])
            elseif maxiter_g>1
                if strcmp(balance,'lump_sum')
                    % NO tax evasion economy, partial equilibrium, lump-sum
                    save([flags.results_folder,'\notaxevasion_pe_lump_sum.mat'])
                elseif strcmp(balance,'tax_cut')
                    % NO tax evasion economy, partial equilibrium, tax cut
                    save([flags.results_folder,'\notaxevasion_pe_cut_tax_all.mat'])
                elseif strcmp(balance,'tax_cut_se')
                    save([flags.results_folder '\notaxevasion_pe_cut_tax_se.mat'])
                end
            end
        elseif do_GE==1
            if maxiter_g==1
                % NO tax evasion economy, general equilibrium, no redis
                save([flags.results_folder,'\notaxevasion_ge.mat'])
            elseif maxiter_g>1
                if strcmp(balance,'lump_sum')
                    % NO tax evasion economy, general equilibrium, lump-sum
                    % redistribution
                    save([flags.results_folder,'\notaxevasion_ge_lump_sum.mat'])
                elseif strcmp(balance,'tax_cut')
                    save([flags.results_folder,'\notaxevasion_ge_cut_tax_all.mat'])
                elseif strcmp(balance,'tax_cut_se')
                    save([flags.results_folder '\notaxevasion_ge_cut_tax_se.mat'])
                end
            end
            
        end
    end
end

end % end function "f_solve_model_withGOV"
